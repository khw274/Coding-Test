## 문제 
august14는 세상에서 가장 맛있는 칵테일이다. 이 칵테일을 만드는 정확한 방법은 아직 세상에 공개되지 않았지만, 들어가는 재료 N개는 공개되어 있다. 

경근이는 인터넷 검색을 통해서 재료 쌍 N-1개의 비율을 알아냈고, 이 비율을 이용해서 칵테일에 들어가는 전체 재료의 비율을 알아낼 수 있다.

총 재료 쌍 N-1개의 비율이 입력으로 주어진다. 이때, 칵테일을 만드는데 필요한 각 재료의 양을 구하는 프로그램을 작성하시오. 이때, 필요한 재료의 질량을 모두 더한 값이 최소가 되어야 한다. 칵테일을 만드는 재료의 양은 정수이고, 총 질량은 0보다 커야한다.

비율은 "a b p q"와 같은 형식이고, a번 재료의 질량을 b번 재료의 질량으로 나눈 값이 p/q라는 뜻이다.
## 입력
첫째 줄에 august14를 만드는데 필요한 재료의 개수 N이 주어지며, N은 10보다 작거나 같은 자연수이다.

둘째 줄부터 N-1개의 줄에는 재료 쌍의 비율이 한 줄에 하나씩 주어지는데, 문제 설명에 나온 형식인 "a b p q"로 주어진다. 재료는 0번부터 N-1까지이며, a와 b는 모두 N-1보다 작거나 같은 음이 아닌 정수이다. p와 q는 9보다 작거나 같은 자연수이다.
## 출력
첫째 줄에 칵테일을 만드는데 필요한 각 재료의 질량을 0번 재료부터 순서대로 공백으로 구분해 출력한다.


## 예제 입력 
```
5
4 0 1 1
4 1 3 1
4 2 5 1
4 3 7 1
```

## 예제 출력  
```
105 35 21 15 105
```
## 코드 풀이
```
#include <iostream>
#include <tuple>  // 3개 이상의 값을 저장하는데 용이
#include <vector>
using namespace std;

// 전역 변수 선언
vector<tuple<int, int, int>> A[10];  // 3중 튜플 인접 리스트
long lcm;  // 최소 공배수, least common multiple
bool visited[10];  // 방문 배열
long d[10];  //노드 값 저장 배열

// 최대 공약수, DFS 함수 선언
long gcd(long a, long b);
void dfs(int node);

int main(){
    ios::sync_with_stdio(0);  // C++ 표준 입출력 속도 향상
    cin.tie(0);  // C++ 입출력 동기화를 끊어 속도 향상
    cout.tie(0);  // C++ 출력 동기화를 끊어 속도 향상
    
    int n;
    cin >> n;  // 노드의 수 입력
    lcm = 1;  // 최소 공배수 초기화, 무조건 1은 확실함
    
    for(int i = 0; i < n - 1; i++){  // 간선 정보 입력
        int a, b, p, q;
        cin >> a >> b >> p >> q;  // 두 노드와 비율 입력
        A[a].push_back(make_tuple(b, p, q));  // 인접 리스트에 튜플 추가
        A[b].push_back(make_tuple(a, q, p));  // a, b가 뒤집히므로 p와 q 반대로 저장
        
        // 데이터 저장할 때마다 비율 관련된 수들의 최소 공배수 업데이트
        lcm *= (p * q / gcd(p, q));  // 두 수의 최소 공배수 = 두 수의 곱 / 최대 공약수
    }
   
    d[0] = lcm;  // 임의의 시작점 0번 노드에 최소 공배수 저장
    dfs(0);  // 임의의 시작점 0번 노드에서 DFS 수행
    long mgcd = d[0];  // 각 노드의 값의 최대 공약수를 찾기 위한 초기값

    for(int i = 1; i < n; i++){  // 0번 노드를 제외하고 1부터 n-1번 노드까지
        mgcd = gcd(mgcd, d[i]);  // 최대 공약수를 구하여 모든 노드의 값을 정규화
    }
    for(int i = 0; i < n; i++){  // 각 노드의 값을 최대 공약수로 나누어 출력
        cout << d[i] / mgcd << ' ';
    }
}

// 최대 공약수 구하기 
long gcd(long a, long b){
    if(b == 0){
        return a;  // b가 0이면 a가 최대 공약수
    }
    else{
        return gcd(b, a % b);  // 재귀 호출을 통해 최대 공약수 계산
    }
}

// DFS 함수 
void dfs(int node){
    visited[node] = true;  // 현재 노드를 방문했음으로 표시
    
    for(tuple<int, int, int> i : A[node]){  // 현재 노드와 연결된 모든 노드 탐색
        int next = get<0>(i);  // 다음 노드, get<접근할 원소의 인덱스>(접근할 튜플의 이름)
        if(!visited[next]){  // 다음 노드를 방문하지 않았다면
            d[next] = d[node] * get<2>(i) / get<1>(i);  // 비율을 이용해 다음 노드의 값 계산
            dfs(next);  // 다음 노드에 대해 DFS 재귀 호출
        }
    }
}

```
## 추가
