## 문제 
1부터 N까지의 수를 임의로 배열한 순열은 총 N! = N×(N-1)×…×2×1 가지가 있다.

임의의 순열은 정렬을 할 수 있다. 예를 들어  N=3인 경우 {1, 2, 3}, {1, 3, 2}, {2, 1, 3}, {2, 3, 1}, {3, 1, 2}, {3, 2, 1}의 순서로 생각할 수 있다. 첫 번째 수가 작은 것이 순서상에서 앞서며, 첫 번째 수가 같으면 두 번째 수가 작은 것이, 두 번째 수도 같으면 세 번째 수가 작은 것이….

N이 주어지면, 아래의 두 소문제 중에 하나를 풀어야 한다. k가 주어지면 k번째 순열을 구하고, 임의의 순열이 주어지면 이 순열이 몇 번째 순열인지를 출력하는 프로그램을 작성하시오.
## 입력
첫째 줄에 N(1 ≤ N ≤ 20)이 주어진다. 둘째 줄의 첫 번째 수는 소문제 번호이다. 1인 경우 k(1 ≤ k ≤ N!)를 입력받고, 2인 경우 임의의 순열을 나타내는 N개의 수를 입력받는다. N개의 수에는 1부터 N까지의 정수가 한 번씩만 나타난다.


## 출력
k번째 수열을 나타내는 N개의 수를 출력하거나, 몇 번째 수열인지를 출력하면 된다.


## 예제 입력 
```
4
1 3
```

## 예제 출력  
```
1 3 2 4
```
## 코드 풀이
```c++
#include <iostream>
using namespace std;

static int n, q;  // 1부터 n까지의 수를 배열한 순열, q(소문제)

static long F[21];  // F(자리별 만들 수 있는 경우의 수 저장)
static long S[21];  // S(순열을 담는 배열)

static bool visited[21] = { false }; // 숫자 사용 여부 저장 배열

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    
    cin >> n >> q;
    
    F[0] = 1;  // 곱을 위해 1로 초기화
    
    // 자릿수 별 팩토리얼 초기화, 각 자릿수에서 만들 수 있는 경우의 수
    for(int i = 1; i <= n; i++){
        F[i] = F[i - 1] * i;  
    }
    
    if(q == 1){  // 소문제 1, k번째 순열 구하기
        long k;
        cin >> k;
        
        for(int i = 1; i <= n; i++){
            for(int j = 1, cnt = 1; j <= n; j++){  // cnt 값과 비례, cnt 수에 따른 순열 값을 넣어야 하기 때문
                
                
                if(visited[j]){  // 이미 사용한 숫자는 사용 X
                    continue;
                }
                
                // 주어진 k에 따라 각 자리에 들어갈 수 찾기
                if(k <= F[n - i] * cnt){
                    k -= (F[n - i] * (cnt - 1));
                    S[i] = j;
                    
                    visited[j] = true;  // 사용 체크
                    break;  // 다음 순열로 넘어감
                }
                cnt++;  // 기준에 맞을 때까지 cnt 증가
            }
        }
        
        for(int i = 1; i <= n; i++){
            cout << S[i] << ' ';
        }
    }
    
    else{
        long k = 1;  // k의 최솟값은 1로 설정
        
        for(int i = 1; i <= n; i++){
            cin >> S[i];
            long cnt = 0;
            
            for(int j = 1; j < S[i]; j++){
                if(!visited[j]){
                    cnt++;  // 미사용 숫자만큼 카운트
                }
            }
            
            k += F[n - i] * cnt;  // (현재 자리 - 1에서 만들 수 있는 순열의 수) * 미사용 숫자 개수 
            visited[S[i]] = true;  // 사용 체크
        }
        
        cout << k << '\n';
    }
}
```
## 추가
